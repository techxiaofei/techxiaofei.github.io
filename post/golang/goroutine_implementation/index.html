<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>一文看懂Go语言协程的设计与原理 | Leftpocket的个人博客</title>
    <meta property="og:title" content="一文看懂Go语言协程的设计与原理 - Leftpocket的个人博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2021-04-18T13:00:51&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2021-04-18T13:00:51&#43;08:00'>
        
    <meta name="Keywords" content="[Golang goroutine]">
    <meta name="description" content="一文看懂Go语言协程的设计与原理">
        
    <meta name="author" content="leftpocket">
    <meta property="og:url" content="https://left-pocket.github.io/post/golang/goroutine_implementation/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <meta name="baidu-site-verification" content="code-swx03nFBNS" />
    <meta name="google-site-verification" content="sGfWBA2Wby1_gxJO3xmOtvpAOU2cCyhwXuU-2m4u75Y" />

    
    <script data-ad-client="ca-pub-6791708134711137" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6791708134711137"
     crossorigin="anonymous"></script>
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    

    
    <meta name="baidu-site-verification" content="code-swx03nFBNS" />
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://left-pocket.github.io">
                        Leftpocket的个人博客
                    </a>
                
                <p class="description">码农在新加坡</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://left-pocket.github.io">首页</a>
                    
                    <a  href="https://left-pocket.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://left-pocket.github.io/about/" title="关于我">关于我</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">一文看懂Go语言协程的设计与原理</h1>
        </header>
        <date class="post-meta meta-date">
            2021年4月18日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='/categories/golang'>Golang</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <h1 id="背景">背景</h1>
<p>Go语言最大的特色就是从语言层面支持并发（Goroutine），Goroutine是Go中最基本的执行单元。事实上每一个Go程序至少有一个Goroutine：main Goroutine。Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。</p>
<p>为了了解Go语言协程的设计，我们从历史设计出发，来看看最终Goroutine怎么一步一步到现在的设计的。</p>
<h3 id="单进程时代">单进程时代</h3>
<p>早期的操作系统每个程序就是一个进程，操作系统在一段时间只能运行一个进程，直到这个进程运行完，才能运行下一个进程，这个时期可以成为单进程时代——串行时代。</p>
<p>如图：进程之间串行执行，A、B、C 三个进程按顺序执行。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_1.png" />   
    </p>
<p>单进程时代的两个问题：</p>
<ol>
<li>单一执行流程、计算机只能一个任务一个任务的处理。</li>
<li>进程阻塞所带来的CPU浪费时间是不可避免的(如进程A阻塞了，然后CPU是单进程没有任何的切换能力，但是需要等待进程A结束后才能执行下个进程）</li>
</ol>
<p>遇到这种问题，我们怎么才能充分利用CPU呢？</p>
<h3 id="多进程时代">多进程时代</h3>
<p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<p>在多进程时代，有了时间片的概念，进程按照调度算法分时间片在 CPU 上执行，A、B、C 三个进程按照时间片并发执行。（调度算法）</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_2.png" />   
    </p>
<p>这样做有两个优点：</p>
<ol>
<li>对于单个核可以并发执行多个进程，应用场景更加丰富，</li>
<li>当某个进程 IO 阻塞时，也能保证 CPU 的利用率。</li>
</ol>
<p>但是随着时代的发展，CPU 通过进程来进行调度的缺点也越发的明显。</p>
<p>进程切换需要：</p>
<ol>
<li>切换页目录以使用新的地址空间</li>
<li>切换内核栈和硬件上下文</li>
</ol>
<p>因为进程拥有太多资源，在创建、切换和销毁的时候，都会占用很长的时间，CPU虽然利用起来了，但CPU有很大的一部分都被用来进行进程调度了。</p>
<p>怎么才能提高CPU的利用率呢？</p>
<h3 id="多线程时代">多线程时代</h3>
<p>所以，轻量级的进程：线程诞生了。线程运行所需要的资源比进程少多了。</p>
<p>对于线程和进程，我们可以这么理解：</p>
<ul>
<li>当进程只有一个线程时，可以认为进程就等于线程。</li>
<li>当进程拥有多个线程时，这些线程会共享相同的<strong>虚拟内存和全局变量</strong>等资源。这些资源在上下文切换时是不需要修改的。</li>
<li>线程也有自己的私有数据，比如<strong>栈和寄存器</strong>等，这些在上下文切换时也是需要保存的。</li>
</ul>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_3.png" />   
    </p>
<p>线程是CPU调度的最小单位, 进程是资源分配的最小单位。</p>
<ul>
<li>进程：进程是资源分配的最小单位，进程在执行过程中拥有独立的内存单元。</li>
<li>线程：线程是CPU调度的最小单位，线程切换只须保存和设置少量寄存器的内容。</li>
</ul>
<p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源。</p>
<p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为每个线程需要有自己的栈空间，大量的线程需要占用大量的内存空间，同时线程的数量还受系统参数<code>threads-max</code>等参数的限制。</p>
<p>有没有更轻量级的线程来支持当今互联网的高并发场景呢。如何才能充分利用CPU、内存等资源的情况下，实现更高的并发？</p>
<h3 id="协程时代">协程时代</h3>
<p>协程作为用户态线程，也是轻量级的线程，用来解决高并发场景下线程切换的资源开销。</p>
<p>你可能知道：线程分为内核态线程和用户态线程，用户态线程需要绑定内核态线程，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程。</p>
<p>用户态线程实际有个名字叫协程（co-routine），为了容易区分，我们使用协程指用户态线程，使用线程指内核态线程。</p>
<p>协程跟线程是有区别的</p>
<ul>
<li>线程/进程是内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</li>
<li>协程 对内核是透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</li>
</ul>
<h1 id="协程的调度">协程的调度</h1>
<h3 id="11-调度">1:1 调度</h3>
<p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，但有一个缺点是协程的创建、删除和切换的代价都由CPU完成，上下文切换很慢，同等于线程切换。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_4.png" />   
    </p>
<h3 id="n1-调度">N:1 调度</h3>
<p>N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上，一是某个程序用不了硬件的多核加速能力，二是一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_5.png" />   
    </p>
<h3 id="mn-调度">M:N 调度</h3>
<p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_6.png" />   
    </p>
<h1 id="go语言协程调度">go语言协程调度</h1>
<p>Go runtime的调度器</p>
<p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p>
<p>而每个goroutine非常轻量级，只占几KB的内存，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。</p>
<p>goroutine建立在操作系统线程基础之上，它与操作系统线程之间实现了一个多对多(M:N)的两级线程模型。</p>
<p>这里的 M:N 是指M个goroutine运行在N个内核线程之上，<strong>内核</strong>负责对这N个操作系统线程进行调度，而这N个系统线程又通过<strong>goroutine调度器</strong>负责对这M个goroutine进行调度和运行。</p>
<h3 id="g-m模型">G-M模型</h3>
<p>Go1.0的协程是G-M模型</p>
<ul>
<li>G指Goroutine，本质上是轻量级线程，包括了调用栈，重要的调度信息，例如channel</li>
<li>M指Machine，一个M关联一个内核OS线程，由操作系统管理。</li>
</ul>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_7.png" />   
    </p>
<p><code>M(内核线程)</code>想要执行、放回G都必须访问<code>全局G队列</code>，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>这个调度器有几个缺点：</p>
<ul>
<li>存在单一全局互斥锁和集中状态。全局锁保护所有 goroutine 相关操作（如：创建、完成、重新调度等），导致锁竞争问题严重；</li>
<li>goroutine 传递问题：经常在 M 之间传递“可运行”的 goroutine，这导致调度延迟增大；</li>
<li>每个线程 M 都需要做内存缓存（M.mcache），导致内存占用过高，且数据局部性较差；</li>
<li>系统调用频繁地阻塞和解除阻塞正在运行的线程，导致额外的性能损耗。</li>
</ul>
<h3 id="g-p-m模型">G-P-M模型</h3>
<p>新的协程调度器引入了P(Processor)，成为了完善的GPM模型。Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/mpg00.png" />   
    </p>
<p>上图中各个模块的作用如下：</p>
<ul>
<li>全局队列：存放等待运行G</li>
<li>P的本地队列：和全局队列类似，存放的也是等待运行的G，存放数量上限256个。新建G时，<code>G优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半G移动到全局队列</code></li>
<li>P列表：所有的P都在程序启动时创建，保存在数组中，最多有GOMAXPROCS个，可通过runtime.GOMAXPROCS(N)修改，N表示设置的个数。</li>
<li>M：每个M代表一个内核线程，操作系统调度器负责把内核线程分配到CPU的核心上执行。</li>
</ul>
<p>简单的来说，一个G的执行需要M和P的支持。一个M在与一个P关联之后形成了一个有效的G运行环境【内核线程 + 上下文环境】。每个P都会包含一个可运行的G的队列 (runq )。</p>
<table>
<thead>
<tr>
<th></th>
<th>数据结构</th>
<th>数量</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>G Goroutine</td>
<td>runtime.g 运行的函数指针，stack，寄存器等。</td>
<td>每次<code>go func</code>都代表一个G，无限制</td>
<td>代表一个用户代码执行流</td>
</tr>
<tr>
<td>P Processor</td>
<td>runtime.p 运行G的上下文，调度器，包括mcache，runq和free g等。</td>
<td>默认为机器核数，可通过 <code>GOMAXPROCS</code> 环境变量调整。</td>
<td>表示执行所需的资源</td>
</tr>
<tr>
<td>M Machine</td>
<td>runtime.m 对应一个内核线程</td>
<td>比P多，M的最大数量可以进行设置，这个初始值是10000</td>
<td>代表执行者，底层线程</td>
</tr>
</tbody>
</table>
<p>调度策略：
调度器核心思想是尽可能避免频繁的创建、销毁线程，对线程进行复用以提高效率。</p>
<ol>
<li>work stealing机制（窃取式）</li>
</ol>
<p>当本线程无G可运行时，从其他线程绑定的P窃取G，而不是直接销毁线程。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/mpg4.png" />   
    </p>
<ol start="2">
<li>hand off机制</li>
</ol>
<p>当本线程M1因为G进行的系统调用阻塞是，线程释放绑定的P，把P转移给其他空闲的M0执行。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/mpg3.png" />   
    </p>
<h3 id="抢占">抢占</h3>
<p>一个goroutine最多占用CPU <strong>10ms</strong>，防止其他goroutine等待太久得不到执行被“饿死”。</p>
<h3 id="全局g队列">全局G队列</h3>
<p>全局G队列是有互斥锁保护的，访问需要竞争锁，新的调度器将其功能弱化了，当M执行work stealing从其他P窃取不到G时，才会去全局G队列获取G。</p>
<h1 id="总结">总结</h1>
<p>本文只是从历史和宏观角度解释了Goroutine的设计原理，当然具体的代码实现远比这个复杂。后续会继续更新Go语言协程的源码到底是怎么实现的。</p>
<h3 id="p的作用是什么">P的作用是什么？</h3>
<p>对比我们可以发现：</p>
<ul>
<li>G-M模型 起初的Go并发性能并不十分亮眼，协程和系统线程的调度比较粗暴，导致很多性能问题，如全局资源锁、M的内存过高等造成许多性能损耗。</li>
<li>加入P的设计之后实现了一个通过 work stealing 的调度算法：由P来维护Goroutine队列并选择一个适当的M绑定。P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量。</li>
</ul>
<h3 id="goroutine存在的意义是什么">goroutine存在的意义是什么？</h3>
<p>goroutine 的存在必然是为了换个方式解决操作系统线程的一些弊端</p>
<ol>
<li>创建和切换太重 操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；</li>
<li>内存使用太重 内核在创建操作系统线程时默认会为其分配一个较大的栈内存，内核在创建操作系统线程时默认会为其分配一个较大的栈内存，同时会有溢出的风险；</li>
</ol>
<p>goroutine的优势也就是 开销小</p>
<ol>
<li>goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；</li>
<li>goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。</li>
</ol>
<h1 id="其他语言的协程">其他语言的协程</h1>
<p>协程是个好东西，不少语言支持了协程，比如：Lua、Erlang，就算语言不支持，也有库支持协程，比如C语言的coroutine、Java的coroutines、C++的libco和libgo、Kotlin的kotlinx.coroutines、Python的gevent。</p>
<p>&lt;全文完&gt;</p>
<p>欢迎关注我的微信公众号：<strong>码农在新加坡</strong>，有更多好的技术分享。

        <img class="mx-auto" alt="pic" src="/img/personal/qrcode_2.png" />   
    </p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/golang/append/">Golang append是并发安全的吗</a></li>
        
        <li><a href="/post/golang/functional_options/">Golang函数式选项(Functional Options)模式</a></li>
        
        <li><a href="/post/golang/decorator/">Golang装饰器(Decorator)设计模式</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/golang'>Golang</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "left-pocket/left-pocket.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2021 <a href="https://left-pocket.github.io">Leftpocket的个人博客 By leftpocket</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://left-pocket.github.io/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">Leftpocket</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://left-pocket.github.io/post/redis/multithreading/" title="一文看懂Redis 6.0多线程IO">一文看懂Redis 6.0多线程IO</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/linux/cp/" title="后端面试之Linux-cp和mv命令的区别">后端面试之Linux-cp和mv命令的区别</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/mysql/table/" title="MySQL对于千万级的大表要怎么优化？">MySQL对于千万级的大表要怎么优化？</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/backend/game_server/" title="游戏服务器和普通服务器的区别">游戏服务器和普通服务器的区别</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/mysql/innodb/" title="后端面试之MySQL-InnoDB一颗B&#43;树可以存放多少行数据？">后端面试之MySQL-InnoDB一颗B&#43;树可以存放多少行数据？</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_dns/" title="从零开始搭建个人博客（五）- 申请免费域名并绑定到个人博客">从零开始搭建个人博客（五）- 申请免费域名并绑定到个人博客</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_vercel/" title="从零开始搭建个人博客（四）- hugo自动部署到vercel">从零开始搭建个人博客（四）- hugo自动部署到vercel</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_advanced/" title="从零开始搭建个人博客（三）- hugo高级配置，让博客更亮眼">从零开始搭建个人博客（三）- hugo高级配置，让博客更亮眼</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_github/" title="从零开始搭建个人博客（二）- 把hugo博客托管到github上">从零开始搭建个人博客（二）- 把hugo博客托管到github上</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_creation/" title="从零开始搭建个人博客（一）- 使用hugo搭建个人博客">从零开始搭建个人博客（一）- 使用hugo搭建个人博客</a>
    </li>
    
</ul>
    </section>

    

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://left-pocket.github.io/categories/c&#43;&#43;/">c&#43;&#43; (3)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/git/">git (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/golang/">Golang (4)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/hugo/">hugo (6)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/leetcode/">leetcode (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/linux/">Linux (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/mysql/">MySQL (5)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/others/">Others (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/redis/">Redis (3)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发 (2)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计 (4)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程 (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E9%9D%A2%E8%AF%95/">面试 (2)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://left-pocket.github.io/tags/c&#43;&#43;/">c&#43;&#43;</a>
    
    <a href="https://left-pocket.github.io/tags/git/">git</a>
    
    <a href="https://left-pocket.github.io/tags/golang/">Golang</a>
    
    <a href="https://left-pocket.github.io/tags/hugo/">hugo</a>
    
    <a href="https://left-pocket.github.io/tags/leetcode/">leetcode</a>
    
    <a href="https://left-pocket.github.io/tags/linux/">Linux</a>
    
    <a href="https://left-pocket.github.io/tags/mysql/">MySQL</a>
    
    <a href="https://left-pocket.github.io/tags/redis/">Redis</a>
    
    <a href="https://left-pocket.github.io/tags/vscode/">vscode</a>
    
    <a href="https://left-pocket.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
    
    <a href="https://left-pocket.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a>
    
    <a href="https://left-pocket.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    
    <a href="https://left-pocket.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://left-pocket.github.io/about/" title="关于我" style="color:#0000FF;">关于我-微信及公众号</a>
        </li>
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/left-pocket" title="Leftpocket的知乎" style="color:#0000FF;">Leftpocket的知乎</a>
        </li>
        
    </ul>
</section>


    
</div>
            </div>
        </div>
    </div>
</body>

</html>