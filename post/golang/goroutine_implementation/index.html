<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    

    <title>一文看懂Go语言协程是如何实现的 | Leftpocket的个人博客</title>
    <meta property="og:title" content="一文看懂Go语言协程是如何实现的 - Leftpocket的个人博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2021-04-18T13:00:51&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2021-04-18T13:00:51&#43;08:00'>
        
    <meta name="Keywords" content="[Golang goroutine]">
    <meta name="description" content="一文看懂Go语言协程是如何实现的">
        
    <meta name="author" content="leftpocket">
    <meta property="og:url" content="https://left-pocket.github.io/post/golang/goroutine_implementation/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <meta name="baidu-site-verification" content="code-swx03nFBNS" />
    <meta name="google-site-verification" content="sGfWBA2Wby1_gxJO3xmOtvpAOU2cCyhwXuU-2m4u75Y" />

    
    <script data-ad-client="ca-pub-6791708134711137" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6791708134711137"
     crossorigin="anonymous"></script>
    
    
    
    
    
        <link rel="stylesheet" href='/css/douban.css'>
    
        <link rel="stylesheet" href='/css/other.css'>
    

    
    <meta name="baidu-site-verification" content="code-swx03nFBNS" />
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://left-pocket.github.io">
                        Leftpocket的个人博客
                    </a>
                
                <p class="description">码农在新加坡</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://left-pocket.github.io">首页</a>
                    
                    <a  href="https://left-pocket.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://left-pocket.github.io/about/" title="关于我">关于我</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">一文看懂Go语言协程是如何实现的</h1>
        </header>
        <date class="post-meta meta-date">
            2021年4月18日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='/categories/golang'>Golang</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <h1 id="背景">背景</h1>
<p>Go语言最大的特色就是从语言层面支持并发（Goroutine），Goroutine是Go中最基本的执行单元。事实上每一个Go程序至少有一个Goroutine：主Goroutine。当程序启动时，它会自动创建。
为了了解Go语言这么设计的原因，我们从历史背景来看，Go语言的并发调度为什么是现在这个样子。</p>
<h3 id="单进程时代">单进程时代</h3>
<p>早期的操作系统每个程序就是一个进程，但是操作系统在一段时间只能运行一个进程，直到这个进程运行完，才能运行下一个进程，这个时期可以成为单进程时代——串行时代。</p>
<p>如图：进程之间串行执行，A、B、C 三个进程按顺序执行。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_1.png" />   
    </p>
<p>单进程时代的两个问题：</p>
<ol>
<li>单一执行流程、计算机只能一个任务一个任务的处理。</li>
<li>进程阻塞所带来的CPU浪费时间是不可避免的(如进程A阻塞了，然后CPU是单进程没有任何的切换能力，但是需要等待进程A结束后才能执行下个进程）</li>
</ol>
<p>遇到这种问题，我们怎么才能充分利用CPU呢？</p>
<h3 id="多进程时代">多进程时代</h3>
<p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<p>在多进程时代，有了时间片的概念，进程按照调度算法分时间片在 CPU 上执行，A、B、C 三个进程按照时间片并发执行。（调度算法）</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_2.png" />   
    </p>
<p>这样做有两个优点：</p>
<ol>
<li>对于单个核可以并发执行多个进程，应用场景更加丰富，</li>
<li>当某个进程 IO 阻塞时，也能保证 CPU 的利用率。</li>
</ol>
<p>但是随着时代的发展，CPU 通过进程来进行调度的缺点也越发的明显。</p>
<p>进程切换需要：</p>
<ol>
<li>切换页目录以使用新的地址空间</li>
<li>切换内核栈和硬件上下文</li>
</ol>
<p>因为进程拥有太多资源，在创建、切换和销毁的时候，都会占用很长的时间，CPU虽然利用起来了，但CPU有很大的一部分都被用来进行进程调度了，怎么才能提高CPU的利用率呢？</p>
<h3 id="多线程时代">多线程时代</h3>
<p>所以，轻量级的进程：线程诞生了。线程运行所需要的资源比进程少多了。</p>
<p>一个进程可以有多个线程，CPU在执行调度的时候切换的是线程，如果下一个线程也是当前进程的，就只有线程切换，“很快”就能完成，如果下一个线程不是当前的进程，就需要切换进程，这就得费点时间了。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_3.png" />   
    </p>
<p>线程是CPU调度的最小单位。</p>
<ul>
<li>进程：进程是资源分配的最小单位，进程在执行过程中拥有独立的内存单元。</li>
<li>线程：线程是CPU调度的最小单位，线程切换只须保存和设置少量寄存器的内容。</li>
</ul>
<p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源</p>
<p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为每个线程需要有自己的栈空间，大量的线程需要占用大量的内存空间，同时线程的数量还受系统参数<code>threads-max, pid_max, max_map_count</code>的限制。</p>
<p>有没有更轻量级的线程来支持当今互联网的高并发场景呢。如何才能充分利用CPU、内存等资源的情况下，实现更高的并发？</p>
<h3 id="协程时代">协程时代</h3>
<p>协程作为用户态线程，也是轻量级的线程，用来解决高并发场景下线程切换的资源开销。</p>
<p>你可能知道：线程分为内核态线程和用户态线程，用户态线程需要绑定内核态线程，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程。</p>
<p>用户态线程实际有个名字叫协程（co-routine），为了容易区分，我们使用协程指用户态线程，使用线程指内核态线程。</p>
<p>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<h1 id="协程的调度">协程的调度</h1>
<h3 id="11-调度">1:1 调度</h3>
<p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，但有一个缺点是协程的创建、删除和切换的代价都由CPU完成，上下文切换很慢，同等于线程切换。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_4.png" />   
    </p>
<h3 id="n1-调度">N:1 调度</h3>
<p>N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上，一是某个程序用不了硬件的多核加速能力，二是一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_5.png" />   
    </p>
<h3 id="mn-调度">M:N 调度</h3>
<p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_6.png" />   
    </p>
<h1 id="go语言协程">go语言协程</h1>
<p>Go runtime的调度器</p>
<p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p>
<p>Go为了提供更容易使用的并发方法，使用了goroutine和channel。从语言层面上实现了并发，和线程一样共享堆，不共享栈，但是避免了切换上下文的额外开销。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。<br>
而每个Goroutine非常轻量级，只占几KB的内存，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。</p>
<p>Goroutine特点：</p>
<ul>
<li>占用内存更小 - 只有几KB</li>
<li>调度更灵活 - runtime调度</li>
</ul>
<p>goroutine建立在操作系统线程基础之上，它与操作系统线程之间实现了一个多对多(M:N)的两级线程模型。</p>
<p>这里的 M:N 是指M个goroutine运行在N个操作系统线程之上，<strong>内核</strong>负责对这N个操作系统线程进行调度，而这N个系统线程又通过<strong>goroutine调度器</strong>负责对这M个goroutine进行调度和运行。<br>
<code>goroutine的调度</code>：是指程序代码按照一定的算法在适当的时候挑选出合适的goroutine并放到CPU上去运行的过程，这些负责对goroutine进行调度的程序代码我们称之为<strong>goroutine调度器。</strong></p>
<h3 id="协程有三大要素-mpg">协程有三大要素: M,P,G</h3>
<ul>
<li>M指Machine，一个M关联一个内核OS线程，由操作系统管理</li>
<li>P指Processor，代表M所需的上下文环境，也是处理用户级代码逻辑的调度器，负责衔接M和G的调度上下文将等待执行的M和G对接。（Go 1.1后加入）</li>
<li>G指Goroutine，本质上是轻量级线程，包括了调用栈，重要的调度信息，例如channel</li>
</ul>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/mpg.png" />   
    </p>
<h3 id="gm模型">GM模型</h3>
<p>Go1.0的协程是GM模型
特点：</p>
<ol>
<li>Go1.0的调度器实现是没有P(Processor)的</li>
<li>调度队列是全局的，对该队列的操作需要竞争同一把锁。</li>
</ol>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/goroutine_7.png" />   
    </p>
<p><code>M(内核线程)</code>想要执行、放回G都必须访问<code>全局G队列</code>，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>这个调度器有几个缺点：</p>
<ul>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</li>
<li>M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M'。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ul>
<h3 id="gpm模型">GPM模型</h3>
<p>新的协程调度器引入了P(Processor)，成为了完善的GPM模型。Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<p>P的数量由环境变量GOMAXPROCS决定，通常和核心数对应，G会有很多个，每个P将Goroutine从一个就绪队列中做Pop操作，减小锁竞争，通常每个P负责一个队列</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/mpg2.png" />   
    </p>
<p>图中看，有2个物理线程M，每一个M都拥有一个context（P），每一个也都有一个正在运行的goroutine。<br>
P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。<br>
图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue）。</p>
<p>Go语言里，启动一个goroutine很容易：<code>go function</code> 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出。</p>
<p><strong>P转移</strong><br>
一个goroutine执行。为何要维护多个上下文P？<br>
因为当一个OS线程被阻塞时，P可以转而投奔另一个OS线程！<br>
图中看到，当一个OS线程M0陷入阻塞时，P转而在OS线程M1上运行。调度器保证有足够的内核线程来运行所以所有的的context（P）。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/mpg3.png" />   
    </p>
<p><strong>分配工作</strong>
图中的M1可能是被创建，或者从线程缓存中取出。当MO返回时，它必须尝试取得一个context P来运行goroutine，一般情况下，它会从其他的OS线程那里steal偷一个context过来，如果没有偷到的话，它就把goroutine放在一个global runqueue里，然后自己就去睡大觉了（放入线程缓存里）。Contexts们也会周期性的检查global runqueue，否则global runqueue上的goroutine永远无法执行。</p>
<p>
        <img class="mx-auto" alt="mpg" src="/img/golang/mpg4.png" />   
    </p>
<p>另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了一个上下文P闲着没事儿干而系统却任然忙碌。但是如果global runqueue没有任务G了，那么P就不得不从其他的上下文P那里拿一些G来执行。一般来说，如果上下文P从其他的上下文P那里要偷一个任务的话，一般就‘偷’run queue的一半，这就确保了每个OS线程都能充分的使用。</p>
<h3 id="p的作用">P的作用</h3>
<p>起初的Go并发性能并不十分亮眼，协程和系统线程的调度比较粗暴，导致很多性能问题，如全局资源锁、M的内存过高等造成许多性能损耗，加入P的设计后实现了一个叫做 work-stealing 的调度算法：由P来维护Goroutine队列并选择一个适当的M绑定</p>
<p>P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量。</p>
<h3 id="goroutine存在的意义是什么">goroutine存在的意义是什么？</h3>
<p>goroutine 的存在必然是为了换个方式解决操作系统线程的一些弊端 — 太重</p>
<ol>
<li>创建和切换太重
操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；</li>
<li>内存使用太重
内核在创建操作系统线程时默认会为其分配一个较大的栈内存，内核在创建操作系统线程时默认会为其分配一个较大的栈内存，同时会有溢出的风险；</li>
</ol>
<ul>
<li>goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；</li>
<li>goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。</li>
</ul>
<h1 id="其他语言的协程">其他语言的协程</h1>
<p>协程是个好东西，不少语言支持了协程，比如：Lua、Erlang、Java，就算语言不支持，也有库支持协程，比如C语言的coroutine、C++的libco和libgo、Kotlin的kotlinx.coroutines、Python的gevent。</p>
<p>&lt;全文完&gt;</p>
<p>欢迎关注我的微信公众号：<strong>码农在新加坡</strong>，有更多好的技术分享。

        <img class="mx-auto" alt="pic" src="/img/personal/qrcode_2.png" />   
    </p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/golang/append/">Golang append是并发安全的吗</a></li>
        
        <li><a href="/post/golang/functional_options/">Golang函数式选项(Functional Options)模式</a></li>
        
        <li><a href="/post/golang/decorator/">Golang装饰器(Decorator)设计模式</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/golang'>Golang</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "left-pocket/left-pocket.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2021 <a href="https://left-pocket.github.io">Leftpocket的个人博客 By leftpocket</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://left-pocket.github.io/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">Leftpocket</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




    <script src='/js/douban.js'></script>

                </div>

                <div id="secondary">
    
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://left-pocket.github.io/post/redis/multithreading/" title="一文看懂Redis 6.0多线程IO">一文看懂Redis 6.0多线程IO</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/linux/cp/" title="后端面试之Linux-cp和mv命令的区别">后端面试之Linux-cp和mv命令的区别</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/mysql/table/" title="MySQL对于千万级的大表要怎么优化？">MySQL对于千万级的大表要怎么优化？</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/backend/game_server/" title="游戏服务器和普通服务器的区别">游戏服务器和普通服务器的区别</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/mysql/innodb/" title="后端面试之MySQL-InnoDB一颗B&#43;树可以存放多少行数据？">后端面试之MySQL-InnoDB一颗B&#43;树可以存放多少行数据？</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_dns/" title="从零开始搭建个人博客（五）- 申请免费域名并绑定到个人博客">从零开始搭建个人博客（五）- 申请免费域名并绑定到个人博客</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_vercel/" title="从零开始搭建个人博客（四）- hugo自动部署到vercel">从零开始搭建个人博客（四）- hugo自动部署到vercel</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_advanced/" title="从零开始搭建个人博客（三）- hugo高级配置，让博客更亮眼">从零开始搭建个人博客（三）- hugo高级配置，让博客更亮眼</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_github/" title="从零开始搭建个人博客（二）- 把hugo博客托管到github上">从零开始搭建个人博客（二）- 把hugo博客托管到github上</a>
    </li>
    
    <li>
        <a href="https://left-pocket.github.io/post/hugo/hugo_creation/" title="从零开始搭建个人博客（一）- 使用hugo搭建个人博客">从零开始搭建个人博客（一）- 使用hugo搭建个人博客</a>
    </li>
    
</ul>
    </section>

    

    

    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://left-pocket.github.io/categories/c&#43;&#43;/">c&#43;&#43; (3)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/git/">git (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/golang/">Golang (4)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/hugo/">hugo (6)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/leetcode/">leetcode (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/linux/">Linux (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/mysql/">MySQL (5)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/others/">Others (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/redis/">Redis (3)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发 (2)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计 (4)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程 (1)</a></li>
    
    <li><a href="https://left-pocket.github.io/categories/%E9%9D%A2%E8%AF%95/">面试 (2)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://left-pocket.github.io/tags/c&#43;&#43;/">c&#43;&#43;</a>
    
    <a href="https://left-pocket.github.io/tags/git/">git</a>
    
    <a href="https://left-pocket.github.io/tags/golang/">Golang</a>
    
    <a href="https://left-pocket.github.io/tags/hugo/">hugo</a>
    
    <a href="https://left-pocket.github.io/tags/leetcode/">leetcode</a>
    
    <a href="https://left-pocket.github.io/tags/linux/">Linux</a>
    
    <a href="https://left-pocket.github.io/tags/mysql/">MySQL</a>
    
    <a href="https://left-pocket.github.io/tags/redis/">Redis</a>
    
    <a href="https://left-pocket.github.io/tags/vscode/">vscode</a>
    
    <a href="https://left-pocket.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
    
    <a href="https://left-pocket.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a>
    
    <a href="https://left-pocket.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    
    <a href="https://left-pocket.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://left-pocket.github.io/about/" title="关于我" style="color:#0000FF;">关于我-微信及公众号</a>
        </li>
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/left-pocket" title="Leftpocket的知乎" style="color:#0000FF;">Leftpocket的知乎</a>
        </li>
        
    </ul>
</section>


    
</div>
            </div>
        </div>
    </div>
</body>

</html>